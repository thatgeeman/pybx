# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_basics.ipynb.

# %% auto 0
__all__ = ['COORD_TYPES', 'ITER_TYPE_JSON', 'ITER_TYPES', 'ITER_TYPES_TUPLE', 'ITER_TYPES_EXTRA', 'ITER_TYPE_HASHED',
           'ALL_ITER_TYPES', 'ALL_TYPES', 'BX_TYPE', 'check_format_types', 'check_length_types', 'check_max_voc',
           'perform_box_checks', 'parse_list', 'parse_dict', 'parse_json', 'Bx', 'BaseBx', 'bbx', 'jbx', 'dbx',
           'parse_basebx', 'infer_box_dtype', 'parse_to_bbx', 'MultiBx', 'mbx', 'get_bx', 'stack_bxs', 'add_bxs',
           'stack_bxs_inplace']

# %% ../nbs/01_basics.ipynb 2
import warnings
import inspect
from typing import Union, Dict
from numpy.typing import ArrayLike

import numpy as np
from fastcore.dispatch import explode_types
from fastcore.foundation import L, noop
from fastcore.basics import concat, store_attr, patch, GetAttr
from fastcore.xtras import is_listy

from pybx.ops import (
    mul,
    sub,
    intersection_box,
    make_single_iterable,
    voc_keys,
    label_keys,
    update_keys,
)
from .excepts import *

COORD_TYPES = (np.int_, int, np.float_)
ITER_TYPE_JSON = Dict[str, str]
ITER_TYPES = (np.ndarray, list, L)
ITER_TYPES_TUPLE = (tuple,)
ITER_TYPES_EXTRA = (dict, ITER_TYPE_JSON)
ITER_TYPE_HASHED = (dict, ITER_TYPE_JSON)
ALL_ITER_TYPES = ITER_TYPES + ITER_TYPES_TUPLE + ITER_TYPES_EXTRA
ALL_TYPES = COORD_TYPES + ITER_TYPES

# %% ../nbs/01_basics.ipynb 5
def check_format_types(b: list, verbose=False):
    """
    Checks if the provided bounding box is in the correct format, typically of [int, int, int, int, str].

    Args:
        b (list): bounding box coordinates with or without label

    Returns:
        bool
    """
    result = all(map(lambda x: isinstance(x, (COORD_TYPES, str)), b))
    if verbose:
        verbose_result = "Passed" if result else "Failed"
        print(f"{verbose_result} `check_format_types`.")
    return result

# %% ../nbs/01_basics.ipynb 10
def check_length_types(b: list, verbose=False):
    """
    Checks if the provided bounding box has an acceptable length and type,
    typically of [int, int, int, int, str] or [int, int, int, int]

    Also checks that all values are positive.

    Args:
        b (list): bounding box coordinates with or without label

    Returns:
        bool
    """
    b_label = True
    # check if len of the coordinates are 4
    b_len = len(b[:4]) == 4
    # check if first 4 items are int and positive
    b_coord_pos = all(
        map(lambda x: x >= 0 if isinstance(x, COORD_TYPES) else False, b[:4])
    )
    # if labels provided, check if string
    if len(b) > 4:
        b_label = all(map(lambda x: isinstance(x, str), b[4:]))

    result = all((b_len, b_coord_pos, b_label))
    if verbose:
        verbose_result = "Passed" if result else "Failed"
        print(
            f"{verbose_result} `check_length_types`. Results were label:{b_label}, len:{b_len}, coords:{b_coord_pos}"
        )
    return result

# %% ../nbs/01_basics.ipynb 14
def check_max_voc(b: list, verbose=False):
    """
    Checks if the provided bounding box bottom right corner (x_max, y_max) is greater
    than the top left corner (x_min, y_min), which is true for voc format.

    Args:
        b (list): bounding box coordinates with or without label

    Returns:
        bool
    """
    assert len(b) >= 4, f"Not enough items in passed bounding box {b}."
    b_coord = b[:4]
    xs, ys = b_coord[::2], b_coord[1::2]
    assert all(
        map(lambda x: isinstance(x, COORD_TYPES), xs)
    ), f"Got `x_min`, `x_max` of wrong type {xs}"
    assert all(
        map(lambda x: isinstance(x, COORD_TYPES), ys)
    ), f"Got `y_min`, `y_max` of wrong type {ys}"

    check_xs = xs[1] > xs[0]
    check_ys = ys[1] > ys[0]
    result = check_xs and check_ys
    if verbose:
        verbose_result = "Passed" if result else "Failed"
        print(
            f"{verbose_result} `check_max_voc`. Results were check_xs:{check_xs}, check_ys:{check_ys}"
        )
    return result

# %% ../nbs/01_basics.ipynb 20
def perform_box_checks(b: list, verbose=False):
    """Calls all checks for bounding boxes: check_max_voc, check_length_types, check_format_types."""
    checks = (
        check_max_voc(b, verbose=verbose),
        check_length_types(b, verbose=verbose),
        check_format_types(b, verbose=verbose),
    )
    return all(checks)

# %% ../nbs/01_basics.ipynb 23
def parse_list(b: Union[list, ArrayLike], verbose=False, no_check=False):
    """
    Takes a list and splits into bounding box coordinates and label

    Args:
        b (list): Bounding box coordinates with or without label

    Returns:
        list: Bounding box coordinates
        str: Bounding box label
    """
    if not no_check:
        assert perform_box_checks(
            b, verbose=verbose
        ), f"Failed `perform_box_checks` for bounding box coordinates {b}"
    coords = list(b[:4])
    label = "unknown"
    if len(b) > 4:
        label = b[-1]
    return [coords], [label]

# %% ../nbs/01_basics.ipynb 37
def parse_dict(b: dict, **kwargs):
    """
    Takes a dict and splits into bounding box coordinates and label

    Args:
        b (dict): Bounding box coordinates with or without label

    Returns:
        list: Bounding box coordinates
        str: Bounding box label
    """
    b_ = []
    keys = update_keys(b)
    for k in keys:
        try:
            b_.append(b[k])
        except KeyError:
            warnings.warn(f"No {k} key in {b}")
            pass
    return parse_list(b_, **kwargs)

# %% ../nbs/01_basics.ipynb 42
def parse_json(b: Union[str, Dict], **kwargs):
    """
    Takes a json string or dict and splits into bounding box coordinates and label

    Args:
        b (json str): Bounding box coordinates with or without label

    Returns:
        list: Bounding box coordinates
        str: Bounding box label
    """
    if isinstance(b, str):
        b = json.loads(b)
    elif isinstance(b, dict):
        return parse_dict(b, **kwargs)
    else:
        raise NotImplementedError(f"Unknown type passed to `parse_json` {b}")
    return parse_dict(b, **kwargs)

# %% ../nbs/01_basics.ipynb 49
class Bx:
    """Interface for all future Bx's"""

    def __init__(self, coords, label: list = None, verbose=False, no_check=False):
        # number of points to represent a box
        n_points = 4
        if no_check:
            coords, parsed_label = coords, label
        else:
            # checks for box validity and parses coordinates
            coords, parsed_label = parse_list(coords)
        # make coord a list of lists
        coords = [coords] if not is_listy(coords[0]) else coords
        # make label a list of single item
        label = label if label else parsed_label
        label = label if is_listy(label) else [label]
        # internal representation as a list
        _coords = coords[0]
        x_min, y_min, x_max, y_max = _coords
        store_attr(
            "x_min, y_min, x_max, y_max, _coords, coords, label, verbose, no_check, n_points"
        )

    def __str__(self):
        return f"Bx(coords={self.coords}, label={self.label})"

    def __repr__(self):
        return self.__str__()

    def __len__(self):
        return len(self.label)

    def get_coords(self):
        return self.coords

    @property
    def coords_as_numpy(self):
        return np.array(self.coords, dtype=int)

    def get_label(self):
        return self.label

    @property
    def bw(self):
        """Calculate width"""
        return self.x_max - self.x_min

    @property
    def bh(self):
        """Calculate height"""
        return self.y_max - self.y_min

    @property
    def cx(self):
        """Calculate center-x"""
        return (self.x_min + self.x_max) / 2.0

    @property
    def cy(self):
        """Calculate center-y"""
        return (self.y_min + self.y_max) / 2.0

    @property
    def area(self):
        """Calculates the absolute value of the area of the box."""
        return abs(self.bw * self.bh)

    @property
    def values(self):
        """Returns the coordinates and label as a single list."""
        return L([[*self._coords, *self.label]])

    @property
    def valid(self):
        """Checks for validity of the box and returns a boolean.
        From `v0.1.3`, validity implies that the box has non-zero area.
        """
        return all(
            [(self.area > 0), (self.x_max > self.x_min), (self.y_max > self.y_min)]
        )

    @property
    def xywh(self):
        """Converts the `pascal_voc` bounding box to `coco` format."""
        return [[self.x_min, self.y_min, self.bw, self.bh, *self.label]]

    def yolo(self, w=1, h=1, normalize=False):
        """Converts the `pascal_voc` bounding box to `yolo` centroids format.
        :param normalize: Whether to normalize the bounding box with image width and height.
        :param w: Width of image. Not to be confused with `BaseBx` attribute `w`.
        :param h: Height of image. Not to be confused with `BaseBx` attribute `h`.
        """
        if normalize:
            assert (w > 1) and (
                h > 1
            ), f"{inspect.stack()[0][3]} of {__name__}: Expected width and height of image with normalize={normalize}."
        _yolo = np.array([self.cx, self.cy, self.bw, self.bh]) / np.tile([w, h], 2)
        _yolo = _yolo.round(4).tolist()
        _yolo.append(*self.label)
        return [_yolo]

# %% ../nbs/01_basics.ipynb 72
class BaseBx(Bx):
    """BaseBx is the most primitive form of representing a bounding box.
    Coordinates and label of a bounding box can be wrapped as a BaseBx using:
    `bbx(coords, label)`.

    :param coords: can be of type `list` or `array` representing a single box.
        - `list` can be formatted with `label`: `[x_min, y_min, x_max, y_max, label]`
            or without `label`: `[x_min, y_min, x_max, y_max]`
        - `array` should be a 1-dimensional array of shape `(4,)`

    :param label: a `list` or `str` that has the class name or label for the object
    in the corresponding box.
    """

    def __init__(self, coords, label: list = None, no_check=False):
        self.index = 0  # Fixes #2, calls itself everytime
        assert isinstance(
            coords, (list, L, np.ndarray)
        ), f"{__name__}: Expected type list or np.ndarray for coords, got {type(coords)}"
        super().__init__(coords, label, no_check=no_check)

    def __str__(self):
        return f"BaseBx(coords={self.coords}, label={self.label})"

# %% ../nbs/01_basics.ipynb 82
def bbx(coords=None, label=None, no_check=False):
    """Alias of the `BaseBx` class using lists."""
    return BaseBx(coords, label, no_check=no_check)

# %% ../nbs/01_basics.ipynb 92
@patch
def iou(self: BaseBx, other):
    """Caclulates the Intersection Over Union (IOU) of the box
    w.r.t. another `BaseBx`. Returns the IOU only if the box is
    considered `valid`, ie non-zero area.
    """
    if not isinstance(other, Bx):
        other = bbx(other)
    if self.valid:
        try:
            int_box = bbx(intersection_box(self.coords, other.coords))
        except NoIntersection:
            return 0.0
        int_area = int_box.area
        union_area = other.area + self.area - int_area
        return round(int_area / union_area, 4)
    return 0.0

# %% ../nbs/01_basics.ipynb 98
@patch
def __iter__(self: BaseBx):
    """Iterates through the boxes in `BaseBx` where self.valid is True."""
    return self


@patch
def __getitem__(self: BaseBx, idx):
    """Gets the item at index idx as a BaseBx."""
    if idx > 0:
        # Fixes #2
        raise IndexError(
            f"BaseBx has only a single coordinate at idx=0. Got idx={idx}."
        )
    return self


@patch
def __next__(self: BaseBx):
    """Iteration is allowed only for valid boxes"""
    try:
        b = self[self.index]
        if not b.valid:
            # 0 area boxes are not valid
            self.index += 1
            return self.__next__()
    except IndexError:
        self.index = 0  # reset index
        raise StopIteration
    self.index += 1
    return b

# %% ../nbs/01_basics.ipynb 104
def jbx(coords=None, label=None):
    """Alias of the `BaseBx` class using json strings."""
    coords, parsed_label = parse_json(coords)
    # make label a list of single item
    label = label if label else parsed_label
    label = label if is_listy(label) else [label]
    # no_check since parse_json already checks
    return BaseBx(coords, label, no_check=True)

# %% ../nbs/01_basics.ipynb 109
def dbx(coords=None, label=None):
    """Alias of the `BaseBx` class using dict."""
    coords, parsed_label = parse_dict(coords)
    # make label a list of single item
    label = label if label else parsed_label
    label = label if is_listy(label) else [label]
    # no_check since parse_dict already checks
    return BaseBx(coords, label, no_check=True)

# %% ../nbs/01_basics.ipynb 115
def parse_basebx(b: BaseBx, no_check=None):
    """Reads the attribute of a BaseBx"""
    if no_check is not None:
        # no_check is typically passed when creating a basebx
        warnings.warn(
            f"no_check={no_check} passed to parse_basebx: are you sure you want to do this?"
        )
    return b.coords, b.label

# %% ../nbs/01_basics.ipynb 118
def infer_box_dtype(b: ALL_ITER_TYPES, **kwargs):
    if isinstance(b, str):
        return "json"
    elif isinstance(b, ITER_TYPES):
        return "list"
    elif isinstance(b, dict):
        return "dict"
    elif isinstance(b, BaseBx):
        return "basebx"
    elif isinstance(b, np.ndarray):
        return "array"
    else:
        raise NotImplementedError(
            f"Unknown type {type(b)} passed to `infer_box_dtype` {b}"
        )

# %% ../nbs/01_basics.ipynb 121
def parse_to_bbx(b, label="unknown", no_check=False):
    """Takes the box and converts it to a BaseBx after inferring the type."""
    if not is_listy(label):
        label = [label]
    box_dtype = infer_box_dtype(b)
    parser = eval(f"parse_{box_dtype}")
    coords, parsed_label = parser(b, no_check=no_check)
    if parsed_label[0] == "unknown":
        parsed_label = label
    return bbx(coords=coords[0], label=parsed_label, no_check=no_check)

# %% ../nbs/01_basics.ipynb 132
class MultiBx:
    """`MultiBx` represents a collection of bounding boxes as lists.
    Objects of type `MultiBx` can be indexed into, which returns a
    `BaseBx` exposing a suite of box-bound operations.
    Multiple coordinates and labels of bounding boxes can be wrapped
    as a `MultiBx` using:
        `mbx(coords, label)`.
    :param coords: can be nested coordinates of type `list` of `list`s/`json` strings
        (`list`s of `dict`s)/`ndarray`s representing multiple boxes.
        If passing a list/json each index of the object should be of the following formats:
        - `list` can be formatted with `label`: `[x_min, y_min, x_max, y_max, label]`
            or without `label`: `[x_min, y_min, x_max, y_max]`
        - `dict` should be in `pascal_voc` format using the keys
            {"x_min": 0, "y_min": 0, "x_max": 1, "y_max": 1, "label": 'none'}
        If passing an `ndarray`, it should be of shape `(N,4)`.

    :param label: a `list` of `str`s that has the class name or label for the object in the
    corresponding box.
    """

    def __init__(self, coords, label: list = None, no_check=False):
        self.index = 0
        self._setup_complete = False
        self.no_check = no_check
        label = label if label else ["unknown"] * len(coords)  # default labels
        # TODO: need a good check for verifying multiple boxes are passed.
        # assert len(coords)>1 and len(label)>1, f"Expected multiple boxes in `MultiBx`: {coords}"
        assert isinstance(coords, ALL_ITER_TYPES)
        self.coords = coords
        self.label = label
        self.__setup__()

    def __setup__(self):
        """Setup the BaseBx for each item at index idx."""
        # anything here
        self._setup_complete = True

    def __len__(self):
        """Gets the length of coordinates."""
        return len(self.label)

    def __getitem__(self, idx):
        return parse_to_bbx(self.coords[idx], self.label[idx], no_check=self.no_check)

    def __iter__(self):
        """Iterates through the boxes in `MultiBx` where self.valid is True."""
        return self

    def __next__(self):
        """Iteration is allowed only for valid boxes"""
        try:
            b = self[self.index]
            if not b.valid:
                # 0 area boxes are not valid
                self.index += 1
                return self.__next__()
        except IndexError:
            self.index = 0  # reset index
            raise StopIteration
        self.index += 1
        return b

    def __str__(self):
        return f"MultiBx(coords: {len(self.coords)}, labels: {len(self.label)})"

    def __repr__(self):
        return self.__str__()

    @property
    def shape(self):
        """Returns the shape of coordinates"""
        # TODO: check for number of points coordinates
        return len(self.coords), 4

    @property
    def coords_as_numpy(self):
        return np.array([b._coords for b in self], dtype=int)

# %% ../nbs/01_basics.ipynb 133
BX_TYPE = (Bx, MultiBx)

# %% ../nbs/01_basics.ipynb 173
def mbx(coords=None, label=None, no_check=False):
    """Alias of the `MultiBx` class."""
    return MultiBx(coords, label, no_check=no_check)

# %% ../nbs/01_basics.ipynb 186
def get_bx(coords, label=None, no_check=False):
    """
    Helper function to check and call the correct type of Bx instance.

    Checks for the type of data passed and calls the respective class
    to generate a Bx instance. Currently only supports ndarray, list, dict,
    tuple, nested list, nested tuple.

    Parameters
    ----------
    coords : ndarray, list, dict, tuple, nested list, nested tuple
        Coordinates of anchor boxes.
    label : list, optional
        Labels for anchor boxes in order, by default None

    Returns
    -------
    Bx
        An instance of MultiBx, ListBx, BaseBx or JsonBx

    Raises
    ------
    NotImplementedError
        If unknown type of coordinates are passed.
    """
    # process ndarray
    if isinstance(coords, np.ndarray):
        coords = np.atleast_2d(coords)
        return mbx(coords, label, no_check)
    # process list
    if isinstance(coords, (list, L)):
        if isinstance(coords[0], COORD_TYPES):
            """If first item is a position"""
            return bbx(coords, label, no_check)
        elif isinstance(coords[0], ITER_TYPES + ITER_TYPES_EXTRA):
            """If fist item is an iterable"""
            return mbx(coords, label, no_check)
        elif isinstance(coords[0], ITER_TYPES_TUPLE):
            """If first item is a tuple"""
            return mbx([list(c) for c in coords], label, no_check)
    # process dict
    if isinstance(coords, dict):
        return bbx([coords], label, no_check)
    # process tuple
    if isinstance(coords, tuple):
        return bbx(list(coords), label, no_check)
    # process BX_TYPE
    if isinstance(coords, BX_TYPE):
        return coords
    else:
        raise NotImplementedError(
            f"{inspect.stack()[0][3]} of {__name__}: Got coords={coords} of type {type(coords)}."
        )

# %% ../nbs/01_basics.ipynb 201
@patch
def __add__(self: BaseBx, other):
    """Pseudo-add method that stacks the provided boxes and labels. Stacking two
    boxes imply that the resulting box is a `MultiBx`: `BaseBx` + `BaseBx`
    = `MultiBx`. This violates the idea of `BaseBx` since the result
    holds more than 1 coordinate/label for the box.
    From `v.2.0`, a `UserWarning` is issued if called.
    Recommended use is either: `BaseBx` + `BaseBx` = `MultiBx` or
    `basics.stack_bxs()`.
    """
    if not isinstance(other, BX_TYPE):
        raise TypeError(
            f"{inspect.stack()[0][3]} of {__name__}: Expected a subclass of {BX_TYPE}"
        )
    else:
        warnings.warn(
            BxViolation(
                f"Change of object type imminent if trying to add "
                f"{type(self)}+{type(other)}. Use {type(other)}+{type(self)} "
                f"instead or basics.stack_bxs()."
            )
        )
    coords = self.coords + other.coords
    label = self.label + other.label
    return mbx(coords, label)


@patch
def __add__(self: MultiBx, other):
    """Pseudo-add method that stacks the provided boxes and labels. Stacking two
    boxes imply that the resulting box is a `MultiBx`: `MultiBx` + `MultiBx`
    = `MultiBx`. Same as `basics.stack_bxs()`.
    """
    if not isinstance(other, BX_TYPE):
        raise TypeError(
            f"{inspect.stack()[0][3]} of {__name__}: Expected type {BX_TYPE}, "
            f"got self={type(self)}, other={type(other)}"
        )
    coords = self.coords + other.coords
    label = self.label + other.label
    return mbx(coords, label)

# %% ../nbs/01_basics.ipynb 202
def stack_bxs(b1, b2):
    """
    Method to stack two Bx-types together. Similar to `__add__` of BxTypes
    but avoids UserWarning.
    :param b1:
    :param b2:
    :return:
    _summary_

    Parameters
    ----------
    b1 : Bx, MultiBx
        Anchor box coordinates Bx
    b2 : Bx, MultiBx
        Anchor box coordinates Bx

    Returns
    -------
    MultiBx
        Stacked anchor box coordinates of MultiBx type.

    Raises
    ------
    TypeError
        If unknown type of coordinates are passed.
    """

    if not isinstance(b1, BX_TYPE):
        raise TypeError(
            f"{inspect.stack()[0][3]} of {__name__}: Expected type {BX_TYPE}, got b1={type(b1)}"
        )
    if not isinstance(b2, BX_TYPE):
        raise TypeError(
            f"{inspect.stack()[0][3]} of {__name__}: Expected type {BX_TYPE}, got b2={type(b2)}"
        )
    if isinstance(b1, BaseBx):
        with warnings.catch_warnings():
            warnings.filterwarnings("ignore")
            return b1 + b2
    return b1 + b2


def add_bxs(b1, b2):
    """Alias of stack_bxs()."""
    return stack_bxs(b1, b2)

# %% ../nbs/01_basics.ipynb 212
def stack_bxs_inplace(b, *args):
    """Stack the passed boxes on top of the first item."""
    for b_ in args:
        b = stack_bxs(b, b_)
    return b

# %% ../nbs/01_basics.ipynb 222
@patch
def get_offset(
    self: BaseBx,
    other: BaseBx,
    normalize=True,
    log_func=np.log,
    sigma=(0.1, 0.2),
    self_is_anchor=False,
):
    """
    Caclulates the offset of the box I with another box O.
    The most basic calculation of offset involves a) taking the distance between the centers: `I_cx - O_cx`, `I_cy - O_cy`.
    b) taking the ratio of the two boxes: `I_w/Ow, I_h/O_h`.

    If `normalize=True`, the center distances and ratios are normalized as per https://arxiv.org/pdf/1512.02325.pdf
    `(I_cx - O_cx)/O_w`, `(I_cy - O_cy)/O_h`, `log(I_w/Ow), log(I_h/O_h)`
    These are further scaled with an appoximation of standard deviation for the distances and ratios
    `((I_cx - O_cx)/O_w)/sigma_c`, `((I_cy - O_cy)/O_h)/sigma_c`, `log(I_w/Ow)/sigma_r, log(I_h/O_h)/sigma_r`

    Args:
        other (BaseBx): Any supported type of bounding box format, even takes a list of coordinates. Typically the anchor box.
        normalize (bool, optional): Whether to normalize the offsets. Defaults to True.
        log_func (func, optional): Function for normalizing the ratio of widths and heights. Defaults to np.log.
        sigma (tuple, optional): Estimated of standard deviation for the distances and ratios. Defaults to (0.1, 0.2).
        self_is_anchor (bool, optional): Typically `other` is assumed to be the anchor box, this flag tells that this assumption is False. Defaults to False.

    Returns:
        list: Offsets of the two bounding boxes
    """
    if isinstance(other, MultiBx):
        warnings.warn(BxViolation(f"Other should be BaseBx, got MultiBx"))
        assert len(other) == 1, f"{other} cannot be converted to single bounding box."
        other = other[0]
    elif not isinstance(other, Bx):
        other = bbx(other)

    if self_is_anchor:
        # if self_is_anchor, ie anchor.get_offset(ground_truth) is called
        anchor = self
        gt = other
    else:
        # if not self_is_anchor, ie ground_truth.get_offset(anchor) is called (default behaviour)
        gt = self
        anchor = other
    # get anchor box w and h
    anchor_bw_norm = anchor.bw
    anchor_bh_norm = anchor.bh
    sigma_c, sigma_r = sigma
    # if not normalize, reset params
    if not normalize:
        log_func = noop
        sigma_c, sigma_r, anchor_bw_norm, anchor_bh_norm = [1.0] * 4
    # center distances
    # norm with anchor box w and h
    cx_offset, cy_offset = (
        (gt.cx - anchor.cx) / anchor_bw_norm,
        (gt.cy - anchor.cy) / anchor_bh_norm,
    )
    # scale of boxes
    w_offset = log_func(gt.bw / anchor_bw_norm)
    h_offset = log_func(gt.bh / anchor_bh_norm)

    offset = np.asarray([cx_offset, cy_offset, w_offset, h_offset])
    # norm with sigmaxy and sigmawh
    # print(sigma_c, sigma_r)
    offset /= np.repeat([sigma_c, sigma_r], 2)
    # not np.tile as norm is cx/sigma_c, cy/sigma_c, w/sigma_r, h/sigma_r
    return L(offset.round(4).tolist())
