[
  {
    "objectID": "anchor.html",
    "href": "anchor.html",
    "title": "Generate anchor boxes",
    "section": "",
    "text": "To generate anchor boxes, we need three basic information:\n\nInput image size, image_sz: To position our anchor boxes within the maximum coordinates (width, height) of the image.\nFeature map size, feature_sz: Feature map is the size (width, height) of the output of a convolutional operation. A \\(10\\times10\\) feature map would mean \\(10\\times10\\) local receptive field locations can be traced back into the input image. These 100 receptive field locations (\\(10\\times10=100\\)) in the input image would act as our initial anchor box candidates.\n\n\n\nAspect ratio of anchor boxes, asp_ratio: To generate anchor boxes with different width to height ratio (default asp_ratio=1).\n\n\nsource\n\nbx\n\n bx (image_sz:(<class'int'>,<class'tuple'>),\n     feature_sz:(<class'int'>,<class'tuple'>), asp_ratio:float=None,\n     clip:bool=True, named:bool=True, anchor_sfx:str='a',\n     min_visibility:float=0.25)\n\nCalculate anchor box coords given an image size and feature size for a single aspect ratio.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nimage_sz\n(<class ‘int’>, <class ‘tuple’>)\n\nimage size (width, height)\n\n\nfeature_sz\n(<class ‘int’>, <class ‘tuple’>)\n\nfeature map size (width, height)\n\n\nasp_ratio\nfloat\nNone\naspect ratio (width:height), by default None\n\n\nclip\nbool\nTrue\nwhether to apply np.clip, by default True\n\n\nnamed\nbool\nTrue\nwhether to return (coords, labels), by default True\n\n\nanchor_sfx\nstr\na\nsuffix anchor label with anchor_sfx, by default “a”\n\n\nmin_visibility\nfloat\n0.25\nminimum visibility dictates the condition for a box to be considered valid. The value corresponds to the ratio of expected area of an anchor boxto the calculated area after clipping to image dimensions., by default 0.25\n\n\nReturns\nndarray\n\nanchor box coordinates in pascal_voc format\n\n\n\n\ncoords_1, labels_1 = bx(100, 10, 0.5)\n\nUsually multiple anchor boxes with different feature_sz and asp_ratio are needed. This requirement arises in the case of multiscale object detection.\nFor multiscale object detection, feature maps from different convolution operations of the network are used to trace back into the input image, to generate anchor boxes. The bxs method of pybx provides this possibility.\n\nsource\n\n\nbxs\n\n bxs (image_sz:(<class'int'>,<class'tuple'>), feature_szs:list=None,\n      asp_ratios:list=None, named:bool=True, **kwargs)\n\nCalculate anchor box coords given an image size and multiple feature sizes for mutiple aspect ratios.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nimage_sz\n(<class ‘int’>, <class ‘tuple’>)\n\nimage size (width, height)\n\n\nfeature_szs\nlist\nNone\nlist of feature map sizes, each feature map size being an int or tuple, by default [(8, 8), (2, 2)]\n\n\nasp_ratios\nlist\nNone\nlist of aspect ratios for anchor boxes, each aspect ratio being a float calculated by (width:height), by default [1 / 2.0, 1.0, 2.0]\n\n\nnamed\nbool\nTrue\nwhether to return (coords, labels), by default True\n\n\nkwargs\n\n\n\n\n\nReturns\nndarray\n\nanchor box coordinates in pascal_voc format\n\n\n\n\ncoords, labels = bxs(100, [10, 8, 5, 2], [1, 0.5, 0.3])\n\n\ncoords.shape, len(labels)\n\n((579, 4), 579)\n\n\nAll methods work with asymetric image_sz (and or feature_szs as well):\n\ncoords, labels = bxs((100, 200), [10, 8, 5, 2], [1, 0.5, 0.3])\n\n\ncoords.shape, len(labels)\n\n((654, 4), 654)"
  },
  {
    "objectID": "01_basics.html",
    "href": "01_basics.html",
    "title": "pybx",
    "section": "",
    "text": "source\n\nmbx\n\n mbx (coords=None, labels=None)\n\nAbstraction of the MultiBx class.\n\nsource\n\n\nbbx\n\n bbx (coords=None, labels=None)\n\nAbstraction of the BaseBx class.\n\nsource\n\n\nlbx\n\n lbx (coords=None, labels=None)\n\nAbstraction of the ListBx class to process lists of lists into MultiBx or BaseBx objects exposing many validation methods\n\nsource\n\n\njbx\n\n jbx (coords=None, labels=None)\n\nAbstraction of the JsonBx class to process json records into MultiBx or BaseBx objects exposing many validation methods\n\nsource\n\n\nadd_bxs\n\n add_bxs (b1, b2)\n\nAlias of stack_bxs().\n\nsource\n\n\nstack_bxs\n\n stack_bxs (b1, b2)\n\nMethod to stack two BxTypes together. Similar to __add__ of BxTypes but avoids UserWarning. :param b1: Bx of class BaseBx, MultiBx, JsonBx, ListBx :param b2: Bx of class BaseBx, MultiBx, JsonBx, ListBx :return: MultiBx\n\nsource\n\n\nget_bx\n\n get_bx (coords, label=None)\n\nHelper function to check and call the correct type of Bx instance. :param coords: coordinates in any allowed raw format list/json/dict/ndarray. :param label: a list of strs that has the class name or label for the object in the corresponding box. :return: an instantialised bounding box.\n\nsource\n\n\nJsonBx\n\n JsonBx (coords, label:list=None)\n\nJsonBx represents a collection of bounding boxes as a list of dicts. Internally called by MultiBx to process coordinates in the format lists of dicts.\n:param coords: can be nested coordinates of type list of dicts representing multiple boxes. If passing a dict, each index of the object should be of the following format: dict should be in pascal_voc format using the keys {“x_min”: 0, “y_min”: 0, “x_max”: 1, “y_max”: 1, “label”: ‘none’} or without “label” key. :param label: a list of strs that has the class name or label for the object in the corresponding box. This is useful if records are passed without “label” key.\n\nsource\n\n\nListBx\n\n ListBx (coords, label:list=None)\n\nListBx represents a collection of bounding boxes as a list of lists. Internally called by MultiBx to process coordinates in the format lists of lists.\n:param coords: can be nested coordinates of type list of lists representing multiple boxes. If passing a list, each index of the object should be of the following format:list can be formatted with label: [x_min, y_min, x_max, y_max, label] or without label: [x_min, y_min, x_max, y_max] :param label: a list of strs that has the class name or label for the object in the corresponding box.\n\nsource\n\n\nMultiBx\n\n MultiBx (coords, label:list=None)\n\nMultiBx represents a collection of bounding boxes as ndarrays. Objects of type MultiBx can be indexed into, which returns a BaseBx exposing a suite of box-bound operations. Multiple coordinates and labels of bounding boxes can be wrapped as a MultiBx using: mbx(coords, label).\n:param coords: can be nested coordinates of type list of lists/json records (lists of dicts)/ndarrays representing multiple boxes. If passing a list/json each index of the object should be of the following formats: - list can be formatted with label: [x_min, y_min, x_max, y_max, label] or without label: [x_min, y_min, x_max, y_max] - dict should be in pascal_voc format using the keys {“x_min”: 0, “y_min”: 0, “x_max”: 1, “y_max”: 1, “label”: ‘none’} If passing an ndarray, it should be of shape (N,4).\n:param label: a list of strs that has the class name or label for the object in the corresponding box.\n\nsource\n\n\nBaseBx\n\n BaseBx (coords, label:list=None)\n\nBaseBx is the most primitive form of representing a bounding box. Coordinates and label of a bounding box can be wrapped as a BaseBx using: bbx(coords, label).\n:param coords: can be of type list/dict/json/array representing a single box. - list can be formatted with label: [x_min, y_min, x_max, y_max, label] or without label: [x_min, y_min, x_max, y_max] - dict should be in pascal_voc format using the keys {“x_min”: 0, “y_min”: 0, “x_max”: 1, “y_max”: 1, “label”: ‘none’} - json records should be a single-object list in pascal_voc format [{“x_min”: 0, “y_min”: 0, “x_max”: 1, “y_max”: 1, “label”: ‘none’}] - array should be a 1-dimensional array of shape (1,4) or (4,)\n:param label: a list or str that has the class name or label for the object in the corresponding box."
  },
  {
    "objectID": "excepts.html",
    "href": "excepts.html",
    "title": "Exceptions",
    "section": "",
    "text": "source\n\nBxViolation\nViolation of Bx properties.\n\nsource\n\n\nNoIntersection\nNo intersection of boxes occur."
  },
  {
    "objectID": "ops.html",
    "href": "ops.html",
    "title": "Operations",
    "section": "",
    "text": "source\n\nupdate_keys\n\n update_keys (annots:dict, default_keys=None)\n\nModify the default class label key that the JsonBx method looks for. By default, JsonBx uses the parameter ops.voc_keys and looks for the key “label” in the dict. If called, update_keys looks inside the parameter ops.label_keys for matching key in the passed annots and uses this as the key to identify class label. Fixes #3. :param annots: dictionary of annotations :param default_keys: voc_keys by default :return: new keys with updated label key\n\nsource\n\n\nintersection_box\n\n intersection_box (b1:numpy.ndarray, b2:numpy.ndarray)\n\nReturn the box that intersects two boxes in pascal_voc format.\n\nsource\n\n\nnamed_idx\n\n named_idx (ncoords:int, sfx:str='')\n\nReturn a list of indices as str matching the array size, suffixed with sfx :param ncoords: number of coordinates :param sfx: suffix to be added to the index :return: list of strings\n\nsource\n\n\nmake_array\n\n make_array (x)\n\nMethod to convert a single dict or a list to an array. :param x: dict with keys {“x_min”: 0, “y_min”: 0, “x_max”: 1, “y_max”: 1, “label”: ‘none’} :return: coords as ndarray, label as list\n\nsource\n\n\nget_op\n\n get_op (op:str)\n\nGiven a string of aps.__ops__, return the function reference.\n\nsource\n\n\nnoop\n\n noop (x, _)\n\nPerform no operation (“no-op”) on x. :param x: input object 1 :param _: input object 2 :return: input object 1\n\nsource\n\n\nmul\n\n mul (x, y)\n\nMultiply two objects.\n\nsource\n\n\nsub\n\n sub (x, y)\n\nSubtract two objects.\n\nsource\n\n\nadd\n\n add (x, y)\n\nAdd two objects."
  },
  {
    "objectID": "sample.html",
    "href": "sample.html",
    "title": "Samples",
    "section": "",
    "text": "source\n\nget_given_array\n\n get_given_array (image_arr, **kwargs)\n\nGet the image_array setup for visualisation. :param image_arr: image nparray :return: reference to protected _get_given_array()\n\nsource\n\n\nget_example\n\n get_example (image_sz:tuple, **kwargs)\n\nGet an example image from the pth given for some image size for a feature size :param image_sz: required image size (will resize the original image) :return: reference to protected _get_example()"
  },
  {
    "objectID": "vis.html",
    "href": "vis.html",
    "title": "Visualizations",
    "section": "",
    "text": "source\n\ndraw_boxes\n\n draw_boxes (img:numpy.ndarray, bbox:list, title=None, ax=None,\n             figsize=(5, 4), color='yellow', no_ticks=False, xo=0, yo=0,\n             squeeze=False, **kwargs)\n\nMethod to draw bounding boxes in an image, can handle multiple bboxes :param figsize: sige of figure :param img: the image array, expects a numpy array :param bbox: list of bounding boxes in json format :param title: image title :param ax: which axis if already present :param yo: y offset for placement of text :param xo: x offset for placement of text :param color: text color or dict of colors for each label as a dict :param no_ticks: whether to set axis ticks off :param squeeze: squeeze axis :return: ax with image\n\nsource\n\n\nget_extents\n\n get_extents (shape)\n\nGet extent parameter of the image.\n\nsource\n\n\nget_color\n\n get_color (color, label=None, default_color='white')\n\nGet colors from color dict for a given label. If label=None, return default_color. :param color: dict of key, value pairs where key is label, value is color :param label: the label for which color is needed :param default_color: :return: str that contains color\n\nsource\n\n\ndraw_rectangle\n\n draw_rectangle (ax, coords, color='white')\n\nDraw a rectangle using matplotlib patch. :param ax: axis :param coords: coordinates in coco format :param color: text color :return: ax object\n\nsource\n\n\ndraw_text\n\n draw_text (ax, xy:tuple, label:str, size=12, color='white', xo=0, yo=0)\n\nWrite text around boxes. :param ax: axis object :param xy: relative ax coordinates x, y to draw the text :param label: label for box :param size: font size :param yo: y offset for placement of text :param xo: x offset for placement of text :param color: text color :return: ax object\n\nsource\n\n\ndraw_outline\n\n draw_outline (obj, linewidth:int)\n\nMake outlines around to object edges for visibility in light backgrounds :param obj: plt objects like text or rectangle :param linewidth: width of the stroke :return: plt object\n\nsource\n\n\ndraw\n\n draw (img:numpy.ndarray, bbox:list, logits=None, alpha=0.4, **kwargs)\n\nMethod to draw an image, box and logits overlayed if passed. :param img: the image array, expects a numpy array :param bbox: list of bounding boxes in json format :param logits: activations that should be overlayed from a neural network (no checks) :param kwargs: kwargs for draw_boxes() :param alpha: same as alpha for matplotlib :return: current axis\n\nsource\n\n\nVisBx\n\n VisBx (image_arr=None, image_sz=None, sample=False, **kwargs)\n\nVisBx is used to visualize the bounding boxes. The image on of which the bounding boxes are to be drawn can be instantiated with VisBx() if needed. Calling the show() method of the VisBx() instance accepts bounding box coordinates and labels that are to be shown. The boxes can be provided as any of the internal objects (MultiBx, BaseBx, …) or as any other raw format accepted by the internal objects.\nDisplaying image array and annotations object: This is the default approach used by VisBx(). If no arguments are passed, a tuple denoting the size for random noise random_img_sz=(100, 100, 1) is expected. Some arguments: :param image_arr: image array of shape (H, W, C). If None, it is set to a random noise image of image_sz=(100,100,3) by default. :param annots: annotations is any accepted format (see above).\nDisplaying from image and annotations file: To load and display the image, set sample=True. Some argmuments: :param ann_fn: annotations file name, default image.jpg :param img_fn: image file name, default annots.json :param load_ann: whether to load ann_fn or just the img_fn. If False, an empty annotations dict is returned: dict(zip(voc_keys, [0, 0, 1, 1, ''])) :param pth: path to find ann_fn and img_fn, default . :param image_sz: size to resize the loaded image a different size (annotations scaled automatically)\nCommon parameters: :param color: A dict of color can be passed to assign specific color to a specific label in the image: color = {'frame': 'blue', 'clock': 'green'} :param logits: Logits as ndarray that should be overlayed on top of the image or bool to generate random logits. :param feature_sz: Feature size to generate random logits if logits is not None."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PyBx",
    "section": "",
    "text": "Installation\npip install pybx\n\n\nUsage\nTo calculate the anchor boxes for a single feature size and aspect ratio, given the image size:\n\nfrom pybx import anchor\n\nimage_sz = (300, 300, 3)\nfeature_sz = (10, 10)\nasp_ratio = 1/2.\n\ncoords, labels = anchor.bx(image_sz, feature_sz, asp_ratio)\n\n100 anchor boxes of asp_ratio 0.5 is generated along with unique labels:\n\ncoords.shape, len(labels)\n\n((100, 4), 100)\n\n\nThe anchor box labels are especially useful, since they are pretty descriptive:\n\ncoords[-1], labels[-1]\n\n(array([274.39339828, 263.78679656, 295.60660172, 300.        ]),\n 'a_10x10_0.5_99')\n\n\nTo calculate anchor boxes for multiple feature sizes and aspect ratios, we use anchor.bxs instead:\n\nfeature_szs = [(10, 10), (8, 8)]\nasp_ratios = [1., 1/2., 2.]\n\ncoords, labels = anchor.bxs(image_sz, feature_szs, asp_ratios)\n\nAll anchor boxes are returned as ndarrays of shape (N,4) where N is the number of boxes.\nThe box labels are even more important now, since they help you uniquely identify to which feature map size or aspect ratios they belong to.\n\ncoords[101], labels[101]\n\n(array([34.39339828,  0.        , 55.60660172, 36.21320344]), 'a_10x10_0.5_1')\n\n\n\ncoords[-1], labels[-1]\n\n(array([254.73349571, 267.99174785, 300.        , 294.50825215]),\n 'a_8x8_2.0_63')\n\n\n\nMultiBx methods\nBox coordinates (with/without labels) in any format (usually ndarray, list, json, dict) can be instantialized as a MultiBx, exposing many useful methods and attributes of MultiBx. For example to calculate the area of each box iteratively:\n\nfrom pybx.basics import * \n# passing anchor boxes and labels from anchor.bxs()\nprint(coords.shape)\n\nboxes = mbx(coords, labels)  \nboxes\n\n(492, 4)\n\n\n<pybx.basics.MultiBx>\n\n\n\nboxes.shape\n\n(492, 4)\n\n\n\nareas = [b.area() for b in boxes]\n\nEach annotation in the MultiBx object boxes is also a BaseBx with its own set of methods and properties.\n\nboxes[-1]\n\n<pybx.basics.BaseBx>\n\n\n\nboxes[-1].coords, boxes[-1].label\n\n(array([254.73349571, 267.99174785, 300.        , 294.50825215]),\n ['a_8x8_2.0_63'])\n\n\nMultiBx objects can also be “added” which stacks them vertically to create a new MultiBx object:\n\nboxes_true = mbx(coords_json)    # annotation as json records\nboxes_anchor = mbx(coords_numpy) # annotation as ndarray\nboxes = boxes_true + boxes_anchor\nboxes\n\n<pybx.basics.MultiBx>\n\n\n\n\nVisualization\nThe vis module of pybx can be used to visualize these “stacks” of MultiBx objects, raw ndarray/list/json records, target annotations and model logits.\n\nPlease refer to Visualising anchor boxes or try out the examples notebook for more details!"
  },
  {
    "objectID": "02_utils.html",
    "href": "02_utils.html",
    "title": "pybx",
    "section": "",
    "text": "source\n\nvalidate_boxes\n\n validate_boxes (coords, image_sz, feature_sz, clip=True,\n                 min_visibility=0.25)\n\nValidate calculated anchor box coords. :param coords: anchor box coordinates :param image_sz: tuple of (width, height) of an image :param feature_sz: tuple of (width, height) of a channel :param clip: whether to apply np.clip :param min_visibility: minimum visibility dictates the condition for a box to be considered valid. The value corresponds to the ratio of expected area to the calculated area after clipping to image dimensions. :return: anchor box coordinates in [pascal_voc] format\n\nsource\n\n\nget_edges\n\n get_edges (image_sz:tuple, feature_sz:tuple, op='noop')\n\nGenerate offsetted top (x_min, y_min) or bottom edges (x_max, y_max) coordinates of a given feature size based on op. if op is noop, gets the top edges. if op is add, gets the bottom edges. :param op: operation for calculating edges, either ‘add’ ‘sub’ ‘noop’ :param image_sz: tuple of (W, H) of an image :param feature_sz: tuple of (W, H) of a channel :return: offsetted edges of each feature\n\nsource\n\n\nas_tuple\n\n as_tuple (x)\n\nGet x as a tuple (x, x) if not already a tuple.\n\n\n\n\nType\nDetails\n\n\n\n\nx\n(int, tuple)\nItem that needs to be converted to a tuple.\n\n\n\n\nas_tuple(2)\n\n(2, 2)"
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "Basic objects",
    "section": "",
    "text": "If in doubt, use get_bx.\n\nsource\n\nmbx\n\n mbx (coords=None, labels=None)\n\nAbstraction of the MultiBx class.\n\nsource\n\n\nbbx\n\n bbx (coords=None, labels=None)\n\nAbstraction of the BaseBx class.\n\nsource\n\n\nlbx\n\n lbx (coords=None, labels=None)\n\nAbstraction of the ListBx class to process lists of lists into MultiBx or BaseBx objects exposing many validation methods\n\nsource\n\n\njbx\n\n jbx (coords=None, labels=None)\n\nAbstraction of the JsonBx class to process json records into MultiBx or BaseBx objects exposing many validation methods\n\nsource\n\n\nadd_bxs\n\n add_bxs (b1, b2)\n\nAlias of stack_bxs().\n\nsource\n\n\nstack_bxs\n\n stack_bxs (b1, b2)\n\nMethod to stack two BxTypes together. Similar to __add__ of BxTypes but avoids UserWarning. :param b1: Bx of class BaseBx, MultiBx, JsonBx, ListBx :param b2: Bx of class BaseBx, MultiBx, JsonBx, ListBx :return: MultiBx\n\nsource\n\n\nget_bx\n\n get_bx (coords, label=None)\n\nHelper function to check and call the correct type of Bx instance. :param coords: coordinates in any allowed raw format list/json/dict/ndarray. :param label: a list of strs that has the class name or label for the object in the corresponding box. :return: an instantialised bounding box.\n\nsource\n\n\nJsonBx\n\n JsonBx (coords, label:list=None)\n\nJsonBx represents a collection of bounding boxes as a list of dicts. Internally called by MultiBx to process coordinates in the format lists of dicts.\n:param coords: can be nested coordinates of type list of dicts representing multiple boxes. If passing a dict, each index of the object should be of the following format: dict should be in pascal_voc format using the keys {“x_min”: 0, “y_min”: 0, “x_max”: 1, “y_max”: 1, “label”: ‘none’} or without “label” key. :param label: a list of strs that has the class name or label for the object in the corresponding box. This is useful if records are passed without “label” key.\n\nsource\n\n\nListBx\n\n ListBx (coords, label:list=None)\n\nListBx represents a collection of bounding boxes as a list of lists. Internally called by MultiBx to process coordinates in the format lists of lists.\n:param coords: can be nested coordinates of type list of lists representing multiple boxes. If passing a list, each index of the object should be of the following format:list can be formatted with label: [x_min, y_min, x_max, y_max, label] or without label: [x_min, y_min, x_max, y_max] :param label: a list of strs that has the class name or label for the object in the corresponding box.\n\nsource\n\n\nMultiBx\n\n MultiBx (coords, label:list=None)\n\nMultiBx represents a collection of bounding boxes as ndarrays. Objects of type MultiBx can be indexed into, which returns a BaseBx exposing a suite of box-bound operations. Multiple coordinates and labels of bounding boxes can be wrapped as a MultiBx using: mbx(coords, label).\n:param coords: can be nested coordinates of type list of lists/json records (lists of dicts)/ndarrays representing multiple boxes. If passing a list/json each index of the object should be of the following formats: - list can be formatted with label: [x_min, y_min, x_max, y_max, label] or without label: [x_min, y_min, x_max, y_max] - dict should be in pascal_voc format using the keys {“x_min”: 0, “y_min”: 0, “x_max”: 1, “y_max”: 1, “label”: ‘none’} If passing an ndarray, it should be of shape (N,4).\n:param label: a list of strs that has the class name or label for the object in the corresponding box.\n\nsource\n\n\nBaseBx\n\n BaseBx (coords, label:list=None)\n\nBaseBx is the most primitive form of representing a bounding box. Coordinates and label of a bounding box can be wrapped as a BaseBx using: bbx(coords, label).\n:param coords: can be of type list/dict/json/array representing a single box. - list can be formatted with label: [x_min, y_min, x_max, y_max, label] or without label: [x_min, y_min, x_max, y_max] - dict should be in pascal_voc format using the keys {“x_min”: 0, “y_min”: 0, “x_max”: 1, “y_max”: 1, “label”: ‘none’} - json records should be a single-object list in pascal_voc format [{“x_min”: 0, “y_min”: 0, “x_max”: 1, “y_max”: 1, “label”: ‘none’}] - array should be a 1-dimensional array of shape (1,4) or (4,)\n:param label: a list or str that has the class name or label for the object in the corresponding box."
  }
]